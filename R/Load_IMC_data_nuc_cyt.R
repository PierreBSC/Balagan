#' @rdname Load_IMC_data_nuc_cyt
#' @title Load data generated by the modified ImcSegmentationPipeline-nuc_cyt
#'   (https://github.com/BodenmillerGroup/ImcSegmentationPipeline)
#' @description This function loads data produced by the modified ImcSegmentationPipeline nuc-cyt where the intensity signal is computed in the cytoplasm, nucleus and whole cell, and output a list containing the different objects
#' @param Path_to_cell_file path to the cell.csv file produced by the ImcSegmentationPipeline (whole cell signal)
#' @param Path_to_cyt_file path to the cyt.csv file produced by the ImcSegmentationPipeline (cytoplasm signal)
#' @param Path_to_nuc_file path to the nuc.csv file produced by the ImcSegmentationPipeline (nuclear signal)
#' @param Path_to_panel_file path to the panel.csv file
#' @param Name_target name of the column from the panel.csv file that provides the gene name
#' @param Name_metal name of the column from the panel.csv file that provides the metal name
#' @param Regex_expression_channel full prefix of the cell.csv file column name that describe marker intensity 
#' @param DNA_channel vector containing the name of the channels that measure cellular DNA amount 
#' @param Use_for_clustering names of channels used for cell clustering 
#' @param Number_of_cells number of cells extracted 
#' @param Reorder_channel how should the channel be renamed. If set to NULL will use the default order in the panel.csv file. 
#' @param X_position_colname column name of the cell.csv file describing the X position of cell centroïd. By default corresponds to CellProfiler output.
#' @param Y_position_colname column name of the cell.csv file describing the Y position of cell centroïd. By default corresponds to CellProfiler output.
#' @param Size_colname column name of the cell.csv file describing the cell size. By default corresponds to CellProfiler output.
#' @param Image_number_colname column name of the cell.csv file describing the ROI of origin for each cell. By default corresponds to CellProfiler output.
#' If set to TRUE it will reorder the panel based on metal mass. 
#' Otherwise provide a path to a file containing the order of the panel
#' @return Returns a list object that can later be used to build a SCE object
#'
#' @examples
#'List_data = Load_IMC_data_nuc_cyt(Path_to_cell_file = "Desktop/analysis/cpout/cell.csv",
#'                          Path_to_cyt_file ="Desktop/analysis/cpout/cyt.csv",
#'                          Path_to_nuc_file = "Desktop/analysis/cpout/nuc.csv",
#'                          Path_to_panel_file ="Desktop/analysis/cpout/panel.csv",
#'                          DNA_channel = c("Iridium191","Iridium193"),
#'                          Reorder_channel = NULL,
#'                          Regex_expression_channel = "Intensity_MeanIntensity_FullStackFiltered_c",
#'                          Use_for_clustering = c("Myeloperoxidase.MPO","CD31","SMA","Cytokeratin.5",
#'                                                 "Keratin.14","Vimentin","CD3","CD68", "Cytokeratin.8.18","CD45",
#'                                                 "Carbonic.Anhydrase.IX","Fibronectin","Ki.67","CD20","CD44","pan.Cytokeratin"),Number_of_cells = NULL)
#'
#' @import readr
#' @export


Load_IMC_data_nuc_cyt = function(Path_to_cell_file,Path_to_cyt_file,Path_to_nuc_file,Path_to_panel_file,
                         Name_target = "Target",Name_metal="Metal.Tag",Name_localisation = "Localisation",
                         Regex_expression_channel = "Intensity_MeanIntensity_FullStackFiltered_c",
                         DNA_channel = NULL,Use_for_clustering = NULL,Number_of_cells=NULL,Reorder_channel=NULL,
                         X_position_colname = "Location_Center_X",Y_position_colname = "Location_Center_Y",
                         Size_colname = "AreaShape_Area",Image_number_colname = "ImageNumber") {
  
  Panel_table = read.csv(Path_to_panel_file)
  
  
  #Get the numeric order of the channel in the cell file
  
  if (is.logical(Reorder_channel)) {
    if (Reorder_channel) {
      Order_channel = order(gsub("[^0-9.-]", "", Panel_table$Metal.Tag))
      Panel_table = Panel_table[Order_channel,]
    }
  }
  
  
  if (is.character(Reorder_channel)) {
    if (!file.exists(Reorder_channel)) {
      stop("The file provided for channel ordering does not exist. Please provide a real one ! \n")
    }
  }
  
  
  if (is.character(Reorder_channel)) {
    if (file.exists(Reorder_channel)) {
      Reorder_channel_file = read.delim(Reorder_channel,header = F)
      Reorder_channel_file = Reorder_channel_file[,1]
      rownames(Panel_table) = Panel_table[,Name_metal]
      Panel_table = Panel_table[Reorder_channel_file,]
    }
  }
  
  
  cat("Loading the cell, cyt and nuc data ... \n")
  
  if (is.null(Number_of_cells)) {
    
    cat("Loading the cell data... \n")
    Raw_cell_data = readr::read_csv(Path_to_cell_file,progress = TRUE)
    Raw_cell_data = as.data.frame(Raw_cell_data)
    
    cat("Loading the cytoplasm data.. \n")
    Raw_cyto_data = readr::read_csv(Path_to_cyt_file,progress = TRUE)
    Raw_cyto_data = as.data.frame(Raw_cyto_data)
    
    cat("Loading the nuclear data.. \n")
    Raw_nuc_data = readr::read_csv(Path_to_nuc_file,progress = TRUE)
    Raw_nuc_data = as.data.frame(Raw_nuc_data)
    
    
  }
  
  if (!is.null(Number_of_cells)) {

    cat("Loading the cell data... \n")
    Raw_cell_data = readr::read_csv(Path_to_cell_file,progress = TRUE,n_max = Number_of_cells)
    Raw_cell_data = as.data.frame(Raw_cell_data)
    
    cat("Loading the cytoplasm data.. \n")
    Raw_cyto_data = readr::read_csv(Path_to_cyt_file,progress = TRUE,n_max = Number_of_cells)
    Raw_cyto_data = as.data.frame(Raw_cyto_data)
    
    cat("Loading the nuclear data.. \n")
    Raw_nuc_data = readr::read_csv(Path_to_nuc_file,progress = TRUE,n_max = Number_of_cells)
    Raw_nuc_data = as.data.frame(Raw_nuc_data)
    
  }
  
  cat("done ! \n ")
  
  #Extracting the mean intensity values
  
  #Get the numeric order of the channel in the cell, nuc and cyt file
  
  Expression_cell_data = Raw_cell_data[,base::grepl(colnames(Raw_cell_data),pattern = Regex_expression_channel)]
  l = colnames(Expression_cell_data)
  l = strsplit(l,split = Regex_expression_channel)
  l = unlist(lapply(l,FUN = function(x) {x[2]}))
  l = as.numeric(l)
  colnames(Expression_cell_data) = make.names(Panel_table[l,Name_target],unique = TRUE)
  
  #
  Expression_cyto_data = Raw_cyto_data[,base::grepl(colnames(Raw_cyto_data),pattern = Regex_expression_channel)]
  l = colnames(Expression_cyto_data)
  l = strsplit(l,split = Regex_expression_channel)
  l = unlist(lapply(l,FUN = function(x) {x[2]}))
  l = as.numeric(l)
  colnames(Expression_cyto_data) = make.names(Panel_table[l,Name_target],unique = TRUE)
  
  #
  Expression_nuc_data = Raw_nuc_data[,base::grepl(colnames(Raw_nuc_data),pattern = Regex_expression_channel)]
  l = colnames(Expression_nuc_data)
  l = strsplit(l,split = Regex_expression_channel)
  l = unlist(lapply(l,FUN = function(x) {x[2]}))
  l = as.numeric(l)
  colnames(Expression_nuc_data) = make.names(Panel_table[l,Name_target],unique = TRUE)
  

  #Extracting the cell annotation table
  
  
  Cell_annotation = data.frame(ImageNumber = Raw_cell_data[,Image_number_colname],
                               ObjectNumber = Raw_cell_data$ObjectNumber,
                               Location_Center_X = Raw_cell_data[,X_position_colname],
                               Location_Center_Y = Raw_cell_data[,Y_position_colname])
  
  if (Size_colname %in% colnames(Raw_cell_data)) {
    Cell_annotation$Cell_size = Raw_cell_data[,Size_colname]
  }
  
  if (Size_colname %in% colnames(Raw_cyto_data)) {
    Cell_annotation$Cyto_size = Raw_cyto_data[,Size_colname]
  }
  
  if (Size_colname %in% colnames(Raw_nuc_data)) {
    Cell_annotation$Nuc_size = Raw_nuc_data[,Size_colname]
  }
  
  
  if (!Size_colname %in% colnames(Raw_cell_data)) {
    warning("The cell size column was not found in the cell file !")
  }
  
  #Extracting the best mask/localisation for each channel
  
  
  if (Name_localisation%in%colnames(Panel_table)) {
    
    List_localisation = Panel_table[,Name_localisation]
    names(List_localisation) = make.names(Panel_table$Target,unique = T)
    if (sum(!List_localisation%in%c("Cell","Cytoplasm","Nuclear"))>0) {
      warning("Annotation of the localisation column is not correct, please check it !")
      Name_localisation = NULL
    }
    
  }
  
  if (!Name_localisation%in%colnames(Panel_table)) {
    
    List_localisation = c()
    List_signal_ratio = c()
    
    for (k in colnames(Expression_cell_data)) {
      
      U = data.frame(Cell= Expression_cell_data[,k],Cyto = Expression_cyto_data[,k],Nuc =Expression_nuc_data[,k])
      Mean_compartment_signal = colMeans(U)
      
      temp_location = c("Cell","Cytoplasm","Nuclear")[which.max(Mean_compartment_signal)]
      temp_signal_ratio = Mean_compartment_signal[which.max(Mean_compartment_signal)]/Mean_compartment_signal[1]
      
      List_signal_ratio = c(List_signal_ratio,temp_signal_ratio)
      List_localisation = c(List_localisation,temp_location)
    }
    names(List_localisation) =colnames(Expression_cell_data)
    
  }
  
  ##Extracting and combining the best expression data
  
  Expression_data = c()
  
  for (k in colnames(Expression_cell_data)) {
    
    if (List_localisation[k]=="Cytoplasm") {
      x = Expression_cyto_data[,k]
      Expression_data = cbind(Expression_data,x)
    }
    
    if (List_localisation[k]=="Nuclear") {
      x = Expression_nuc_data[,k]
      Expression_data = cbind(Expression_data,x)
    }
    
    if (List_localisation[k]=="Cell") {
      x = Expression_cell_data[,k]
      Expression_data = cbind(Expression_data,x)
    }
    
  }
  colnames(Expression_data) = colnames(Expression_cell_data)
  Expression_data = as.data.frame(Expression_data)
  
  #Extracting the gene annotation table
  
  Gene_annotation = data.frame(Used_for_clustering = colnames(Expression_data)%in%Use_for_clustering,
                               DNA_channel = colnames(Expression_data)%in%DNA_channel,
                               Localisation = List_localisation,
                               row.names = colnames(Expression_data))
  return(list(Expression_data = Expression_data,
              Cell_annotation = Cell_annotation,
              Gene_annotation = Gene_annotation))
  
  
}



